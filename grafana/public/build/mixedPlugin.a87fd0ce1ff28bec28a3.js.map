{"version":3,"file":"mixedPlugin.a87fd0ce1ff28bec28a3.js","mappings":"y7CAqBO,MAAMA,UAAwBC,EAAAA,cACnCC,YAAYC,GACVC,MAAMD,GAGRE,MAAMC,GAEJ,MAAMC,EAAUD,EAAQE,QAAQC,QAAQC,IAAM,MAC5C,MAf+B,iBAexB,UAAAA,EAAEC,kBAAF,eAAcC,QAGvB,IAAKL,EAAQM,OACX,OAAOC,EAAAA,EAAAA,IAAG,CAAEC,KAAM,KAIpB,MAAMC,GAAuCC,EAAAA,EAAAA,SAAQV,EAAS,kBACxDW,EAA0B,GAEhC,IAAK,MAAMC,KAAOH,EAAM,CACtB,MAAMR,EAAUQ,EAAKG,GAErBD,EAAME,KAAK,CACTT,YAAYU,EAAAA,EAAAA,oBAAmBC,IAAId,EAAQ,GAAGG,WAAYL,EAAQiB,YAClEf,QAAAA,IAKJ,OAAKU,EAAML,OAIJW,KAAKC,aAAaP,EAAOZ,IAHvBQ,EAAAA,EAAAA,IAAG,CAAEC,KAAM,KAMtBU,aAAaP,EAAyBZ,GACpC,MAAMoB,EAAiBR,EAAMT,OAAOe,KAAKG,aAAaC,KAAI,CAACvB,EAAOwB,KAChEC,EAAAA,EAAAA,GAAKzB,EAAMM,YAAYoB,MACrBC,EAAAA,EAAAA,IAAUC,IACR,MAAMC,GAAYC,EAAAA,EAAAA,WAAU7B,GAI5B,OAHA4B,EAAUE,UAAa,SAAQP,KAAKK,EAAUE,WAAa,KAC3DF,EAAU1B,QAAUH,EAAMG,SAEnBsB,EAAAA,EAAAA,GAAKG,EAAI5B,MAAM6B,IAAYH,MAChCH,EAAAA,EAAAA,IAAKS,GACH,iBACKA,EADL,CAEEtB,KAAMsB,EAAStB,MAAQ,GACvBuB,MAAOC,EAAAA,aAAAA,QACPpB,IAAM,SAAQU,KAAKQ,EAASlB,KAAO,UAGvCqB,EAAAA,EAAAA,MACAC,EAAAA,EAAAA,IAAYC,KACVA,GAAMC,EAAAA,EAAAA,kBAAiBD,IACnBE,QAAW,GAAEX,EAAIY,SAASH,EAAIE,WAE3B9B,EAAAA,EAAAA,IAAwB,CAC7B,CACEC,KAAM,GACNuB,MAAOC,EAAAA,aAAAA,MACPO,MAAOJ,EACPvB,IAAM,SAAQU,KAAKK,EAAUE,WAAa,kBASxD,OAAOW,EAAAA,EAAAA,GAASrB,GAAgBK,MA8B3BiB,EAAAA,EAAAA,IAAO,CAACC,EAA0BC,IAChCA,EAAQF,QAAO,CAACG,EAAUC,KAC/BD,EAAS/B,KAAKiC,MAAMF,EAAUC,GACvBD,IACNF,IACF,KAnCwDrB,EAAAA,EAAAA,GAAIJ,KAAK8B,oBAAoBC,EAAAA,EAAAA,MAGxFC,iBACE,OAAOC,QAAQC,QAAQ,IAGjB/B,YAAYtB,GAClB,OAAOA,GAASsD,MAAMC,QAAQvD,EAAMG,UAAYH,EAAMG,QAAQK,OAAS,EAGjEyC,kBAAkBO,GACxB,MAAM,OAAEhD,GAAWgD,EAEnB,GAAe,IAAXhD,EACF,OAAOgD,EAGT,MAAMf,EAAQe,EAAUC,MAAMzB,GAAaA,EAASC,QAAUC,EAAAA,aAAAA,QAO9D,OANIO,EACFe,EAAUzC,KAAK0B,GAEfe,EAAUhD,EAAS,GAAGyB,MAAQC,EAAAA,aAAAA,KAGzBsB","sources":["webpack://grafana/./public/app/plugins/datasource/mixed/MixedDataSource.ts"],"sourcesContent":["import { cloneDeep, groupBy } from 'lodash';\nimport { forkJoin, from, Observable, of, OperatorFunction } from 'rxjs';\nimport { catchError, map, mergeAll, mergeMap, reduce, toArray } from 'rxjs/operators';\n\nimport {\n  DataQuery,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  LoadingState,\n} from '@grafana/data';\nimport { getDataSourceSrv, toDataQueryError } from '@grafana/runtime';\n\nexport const MIXED_DATASOURCE_NAME = '-- Mixed --';\n\nexport interface BatchedQueries {\n  datasource: Promise<DataSourceApi>;\n  targets: DataQuery[];\n}\n\nexport class MixedDatasource extends DataSourceApi<DataQuery> {\n  constructor(instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  query(request: DataQueryRequest<DataQuery>): Observable<DataQueryResponse> {\n    // Remove any invalid queries\n    const queries = request.targets.filter((t) => {\n      return t.datasource?.uid !== MIXED_DATASOURCE_NAME;\n    });\n\n    if (!queries.length) {\n      return of({ data: [] } as DataQueryResponse); // nothing\n    }\n\n    // Build groups of queries to run in parallel\n    const sets: { [key: string]: DataQuery[] } = groupBy(queries, 'datasource.uid');\n    const mixed: BatchedQueries[] = [];\n\n    for (const key in sets) {\n      const targets = sets[key];\n\n      mixed.push({\n        datasource: getDataSourceSrv().get(targets[0].datasource, request.scopedVars),\n        targets,\n      });\n    }\n\n    // Missing UIDs?\n    if (!mixed.length) {\n      return of({ data: [] } as DataQueryResponse); // nothing\n    }\n\n    return this.batchQueries(mixed, request);\n  }\n\n  batchQueries(mixed: BatchedQueries[], request: DataQueryRequest<DataQuery>): Observable<DataQueryResponse> {\n    const runningQueries = mixed.filter(this.isQueryable).map((query, i) =>\n      from(query.datasource).pipe(\n        mergeMap((api: DataSourceApi) => {\n          const dsRequest = cloneDeep(request);\n          dsRequest.requestId = `mixed-${i}-${dsRequest.requestId || ''}`;\n          dsRequest.targets = query.targets;\n\n          return from(api.query(dsRequest)).pipe(\n            map((response) => {\n              return {\n                ...response,\n                data: response.data || [],\n                state: LoadingState.Loading,\n                key: `mixed-${i}-${response.key || ''}`,\n              } as DataQueryResponse;\n            }),\n            toArray(),\n            catchError((err) => {\n              err = toDataQueryError(err);\n              err.message = `${api.name}: ${err.message}`;\n\n              return of<DataQueryResponse[]>([\n                {\n                  data: [],\n                  state: LoadingState.Error,\n                  error: err,\n                  key: `mixed-${i}-${dsRequest.requestId || ''}`,\n                },\n              ]);\n            })\n          );\n        })\n      )\n    );\n\n    return forkJoin(runningQueries).pipe(flattenResponses(), map(this.finalizeResponses), mergeAll());\n  }\n\n  testDatasource() {\n    return Promise.resolve({});\n  }\n\n  private isQueryable(query: BatchedQueries): boolean {\n    return query && Array.isArray(query.targets) && query.targets.length > 0;\n  }\n\n  private finalizeResponses(responses: DataQueryResponse[]): DataQueryResponse[] {\n    const { length } = responses;\n\n    if (length === 0) {\n      return responses;\n    }\n\n    const error = responses.find((response) => response.state === LoadingState.Error);\n    if (error) {\n      responses.push(error); // adds the first found error entry so error shows up in the panel\n    } else {\n      responses[length - 1].state = LoadingState.Done;\n    }\n\n    return responses;\n  }\n}\n\nfunction flattenResponses(): OperatorFunction<DataQueryResponse[][], DataQueryResponse[]> {\n  return reduce((all: DataQueryResponse[], current) => {\n    return current.reduce((innerAll, innerCurrent) => {\n      innerAll.push.apply(innerAll, innerCurrent);\n      return innerAll;\n    }, all);\n  }, []);\n}\n"],"names":["MixedDatasource","DataSourceApi","constructor","instanceSettings","super","query","request","queries","targets","filter","t","datasource","uid","length","of","data","sets","groupBy","mixed","key","push","getDataSourceSrv","get","scopedVars","this","batchQueries","runningQueries","isQueryable","map","i","from","pipe","mergeMap","api","dsRequest","cloneDeep","requestId","response","state","LoadingState","toArray","catchError","err","toDataQueryError","message","name","error","forkJoin","reduce","all","current","innerAll","innerCurrent","apply","finalizeResponses","mergeAll","testDatasource","Promise","resolve","Array","isArray","responses","find"],"sourceRoot":""}
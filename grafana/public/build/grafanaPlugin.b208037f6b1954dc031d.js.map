{"version":3,"file":"grafanaPlugin.b208037f6b1954dc031d.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/datasource/grafana/components/QueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/grafana/components/AnnotationQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/grafana/datasource.ts","webpack://grafana/./public/app/plugins/datasource/grafana/module.ts","webpack://grafana/./public/app/plugins/datasource/grafana/types.ts"],"sourcesContent":["import React, { PureComponent } from 'react';\n\nimport {\n  QueryEditorProps,\n  SelectableValue,\n  dataFrameFromJSON,\n  rangeUtil,\n  DataQueryRequest,\n  DataFrame,\n} from '@grafana/data';\nimport { config, getBackendSrv, getDataSourceSrv } from '@grafana/runtime';\nimport { InlineField, Select, Alert, Input, InlineFieldRow } from '@grafana/ui';\n\nimport { GrafanaDatasource } from '../datasource';\nimport { defaultQuery, GrafanaQuery, GrafanaQueryType } from '../types';\n\ntype Props = QueryEditorProps<GrafanaDatasource, GrafanaQuery>;\n\nconst labelWidth = 12;\n\ninterface State {\n  channels: Array<SelectableValue<string>>;\n  channelFields: Record<string, Array<SelectableValue<string>>>;\n  folders?: Array<SelectableValue<string>>;\n}\n\nexport class QueryEditor extends PureComponent<Props, State> {\n  state: State = { channels: [], channelFields: {} };\n\n  queryTypes: Array<SelectableValue<GrafanaQueryType>> = [\n    {\n      label: 'Random Walk',\n      value: GrafanaQueryType.RandomWalk,\n      description: 'Random signal within the selected time range',\n    },\n    {\n      label: 'Live Measurements',\n      value: GrafanaQueryType.LiveMeasurements,\n      description: 'Stream real-time measurements from Grafana',\n    },\n    {\n      label: 'List public files',\n      value: GrafanaQueryType.List,\n      description: 'Show directory listings for public resources',\n    },\n  ];\n\n  constructor(props: Props) {\n    super(props);\n\n    if (config.featureToggles.panelTitleSearch) {\n      this.queryTypes.push({\n        label: 'Search',\n        value: GrafanaQueryType.Search,\n        description: 'Search for grafana resources',\n      });\n    }\n  }\n\n  loadChannelInfo() {\n    getBackendSrv()\n      .fetch({ url: 'api/live/list' })\n      .subscribe({\n        next: (v: any) => {\n          const channelInfo = v.data?.channels as any[];\n          if (channelInfo?.length) {\n            const channelFields: Record<string, Array<SelectableValue<string>>> = {};\n            const channels: Array<SelectableValue<string>> = channelInfo.map((c) => {\n              if (c.data) {\n                const distinctFields = new Set<string>();\n                const frame = dataFrameFromJSON(c.data);\n                for (const f of frame.fields) {\n                  distinctFields.add(f.name);\n                }\n                channelFields[c.channel] = Array.from(distinctFields).map((n) => ({\n                  value: n,\n                  label: n,\n                }));\n              }\n              return {\n                value: c.channel,\n                label: c.channel + ' [' + c.minute_rate + ' msg/min]',\n              };\n            });\n\n            this.setState({ channelFields, channels });\n          }\n        },\n      });\n  }\n\n  loadFolderInfo() {\n    const query: DataQueryRequest<GrafanaQuery> = {\n      targets: [{ queryType: GrafanaQueryType.List, refId: 'A' }],\n    } as any;\n\n    getDataSourceSrv()\n      .get('-- Grafana --')\n      .then((ds) => {\n        const gds = ds as GrafanaDatasource;\n        gds.query(query).subscribe({\n          next: (rsp) => {\n            if (rsp.data.length) {\n              const names = (rsp.data[0] as DataFrame).fields[0];\n              const folders = names.values.toArray().map((v) => ({\n                value: v,\n                label: v,\n              }));\n              this.setState({ folders });\n            }\n          },\n        });\n      });\n  }\n\n  componentDidMount() {\n    this.loadChannelInfo();\n  }\n\n  onQueryTypeChange = (sel: SelectableValue<GrafanaQueryType>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, queryType: sel.value! });\n    onRunQuery();\n\n    // Reload the channel list\n    this.loadChannelInfo();\n  };\n\n  onChannelChange = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, channel: sel?.value });\n    onRunQuery();\n  };\n\n  onFieldNamesChange = (item: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let fields: string[] = [];\n    if (Array.isArray(item)) {\n      fields = item.map((v) => v.value);\n    } else if (item.value) {\n      fields = [item.value];\n    }\n\n    // When adding the first field, also add time (if it exists)\n    if (fields.length === 1 && !query.filter?.fields?.length && query.channel) {\n      const names = this.state.channelFields[query.channel] ?? [];\n      const tf = names.find((f) => f.value === 'time' || f.value === 'Time');\n      if (tf && tf.value && tf.value !== fields[0]) {\n        fields = [tf.value, ...fields];\n      }\n    }\n\n    onChange({\n      ...query,\n      filter: {\n        ...query.filter,\n        fields,\n      },\n    });\n    onRunQuery();\n  };\n\n  checkAndUpdateValue = (key: keyof GrafanaQuery, txt: string) => {\n    const { onChange, query, onRunQuery } = this.props;\n    if (key === 'buffer') {\n      let buffer: number | undefined;\n      if (txt) {\n        try {\n          buffer = rangeUtil.intervalToSeconds(txt) * 1000;\n        } catch (err) {\n          console.warn('ERROR', err);\n        }\n      }\n      onChange({\n        ...query,\n        buffer,\n      });\n    } else {\n      onChange({\n        ...query,\n        [key]: txt,\n      });\n    }\n    onRunQuery();\n  };\n\n  handleEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    this.checkAndUpdateValue('buffer', (e.target as any).value);\n  };\n\n  handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    this.checkAndUpdateValue('buffer', e.target.value);\n  };\n\n  renderMeasurementsQuery() {\n    let { channel, filter, buffer } = this.props.query;\n    let { channels, channelFields } = this.state;\n    let currentChannel = channels.find((c) => c.value === channel);\n    if (channel && !currentChannel) {\n      currentChannel = {\n        value: channel,\n        label: channel,\n        description: `Connected to ${channel}`,\n      };\n      channels = [currentChannel, ...channels];\n    }\n\n    const distinctFields = new Set<string>();\n    const fields: Array<SelectableValue<string>> = channel ? channelFields[channel] ?? [] : [];\n    // if (data && data.series?.length) {\n    //   for (const frame of data.series) {\n    //     for (const field of frame.fields) {\n    //       if (distinctFields.has(field.name) || !field.name) {\n    //         continue;\n    //       }\n    //       fields.push({\n    //         value: field.name,\n    //         label: field.name,\n    //         description: `(${getFrameDisplayName(frame)} / ${field.type})`,\n    //       });\n    //       distinctFields.add(field.name);\n    //     }\n    //   }\n    // }\n    if (filter?.fields) {\n      for (const f of filter.fields) {\n        if (!distinctFields.has(f)) {\n          fields.push({\n            value: f,\n            label: `${f} (not loaded)`,\n            description: `Configured, but not found in the query results`,\n          });\n          distinctFields.add(f);\n        }\n      }\n    }\n\n    let formattedTime = '';\n    if (buffer) {\n      formattedTime = rangeUtil.secondsToHms(buffer / 1000);\n    }\n\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Channel\" grow={true} labelWidth={labelWidth}>\n            <Select\n              menuShouldPortal\n              options={channels}\n              value={currentChannel || ''}\n              onChange={this.onChannelChange}\n              allowCustomValue={true}\n              backspaceRemovesValue={true}\n              placeholder=\"Select measurements channel\"\n              isClearable={true}\n              noOptionsMessage=\"Enter channel name\"\n              formatCreateLabel={(input: string) => `Connect to: ${input}`}\n            />\n          </InlineField>\n        </div>\n        {channel && (\n          <div className=\"gf-form\">\n            <InlineField label=\"Fields\" grow={true} labelWidth={labelWidth}>\n              <Select\n                menuShouldPortal\n                options={fields}\n                value={filter?.fields || []}\n                onChange={this.onFieldNamesChange}\n                allowCustomValue={true}\n                backspaceRemovesValue={true}\n                placeholder=\"All fields\"\n                isClearable={true}\n                noOptionsMessage=\"Unable to list all fields\"\n                formatCreateLabel={(input: string) => `Field: ${input}`}\n                isSearchable={true}\n                isMulti={true}\n              />\n            </InlineField>\n            <InlineField label=\"Buffer\">\n              <Input\n                placeholder=\"Auto\"\n                width={12}\n                defaultValue={formattedTime}\n                onKeyDown={this.handleEnterKey}\n                onBlur={this.handleBlur}\n                spellCheck={false}\n              />\n            </InlineField>\n          </div>\n        )}\n\n        <Alert title=\"Grafana Live - Measurements\" severity=\"info\">\n          This supports real-time event streams in Grafana core. This feature is under heavy development. Expect the\n          interfaces and structures to change as this becomes more production ready.\n        </Alert>\n      </>\n    );\n  }\n\n  onFolderChanged = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, path: sel?.value });\n    onRunQuery();\n  };\n\n  renderListPublicFiles() {\n    let { path } = this.props.query;\n    let { folders } = this.state;\n    if (!folders) {\n      folders = [];\n      this.loadFolderInfo();\n    }\n    const currentFolder = folders.find((f) => f.value === path);\n    if (path && !currentFolder) {\n      folders = [\n        ...folders,\n        {\n          value: path,\n          label: path,\n        },\n      ];\n    }\n\n    return (\n      <InlineFieldRow>\n        <InlineField label=\"Path\" grow={true} labelWidth={labelWidth}>\n          <Select\n            menuShouldPortal\n            options={folders}\n            value={currentFolder || ''}\n            onChange={this.onFolderChanged}\n            allowCustomValue={true}\n            backspaceRemovesValue={true}\n            placeholder=\"Select folder\"\n            isClearable={true}\n            formatCreateLabel={(input: string) => `Folder: ${input}`}\n          />\n        </InlineField>\n      </InlineFieldRow>\n    );\n  }\n\n  handleSearchEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    this.checkAndUpdateValue('query', (e.target as any).value);\n  };\n\n  handleSearchBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    this.checkAndUpdateValue('query', e.target.value);\n  };\n\n  renderSearch() {\n    let { query } = this.props.query;\n    return (\n      <InlineFieldRow>\n        <InlineField label=\"Query\" grow={true} labelWidth={labelWidth}>\n          <Input\n            placeholder=\"Everything\"\n            defaultValue={query ?? ''}\n            onKeyDown={this.handleSearchEnterKey}\n            onBlur={this.handleSearchBlur}\n            spellCheck={false}\n          />\n        </InlineField>\n      </InlineFieldRow>\n    );\n  }\n\n  render() {\n    const query = {\n      ...defaultQuery,\n      ...this.props.query,\n    };\n\n    return (\n      <>\n        <InlineFieldRow>\n          <InlineField label=\"Query type\" grow={true} labelWidth={labelWidth}>\n            <Select\n              menuShouldPortal\n              options={this.queryTypes}\n              value={this.queryTypes.find((v) => v.value === query.queryType) || this.queryTypes[0]}\n              onChange={this.onQueryTypeChange}\n            />\n          </InlineField>\n        </InlineFieldRow>\n        {query.queryType === GrafanaQueryType.LiveMeasurements && this.renderMeasurementsQuery()}\n        {query.queryType === GrafanaQueryType.List && this.renderListPublicFiles()}\n        {query.queryType === GrafanaQueryType.Search && this.renderSearch()}\n      </>\n    );\n  }\n}\n","import { css } from '@emotion/css';\nimport React from 'react';\n\nimport { SelectableValue } from '@grafana/data';\nimport { Field, FieldSet, Select, Switch } from '@grafana/ui';\nimport { TagFilter } from 'app/core/components/TagFilter/TagFilter';\nimport { getAnnotationTags } from 'app/features/annotations/api';\n\nimport { GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQuery } from '../types';\n\nconst matchTooltipContent = 'Enabling this returns annotations that match any of the tags specified below';\n\nconst tagsTooltipContent = (\n  <div>Specify a list of tags to match. To specify a key and value tag use `key:value` syntax.</div>\n);\n\nconst annotationTypes = [\n  {\n    label: 'Dashboard',\n    value: GrafanaAnnotationType.Dashboard,\n    description: 'Query for events created on this dashboard and show them in the panels where they where created',\n  },\n  {\n    label: 'Tags',\n    value: GrafanaAnnotationType.Tags,\n    description: 'This will fetch any annotation events that match the tags filter',\n  },\n];\n\nconst limitOptions = [10, 50, 100, 200, 300, 500, 1000, 2000].map((limit) => ({\n  label: String(limit),\n  value: limit,\n}));\n\ninterface Props {\n  query: GrafanaQuery;\n  onChange: (newValue: GrafanaAnnotationQuery) => void;\n}\n\nexport default function AnnotationQueryEditor({ query, onChange }: Props) {\n  const annotationQuery = query as GrafanaAnnotationQuery;\n  const { limit, matchAny, tags, type } = annotationQuery;\n  const styles = getStyles();\n\n  const onFilterByChange = (newValue: SelectableValue<GrafanaAnnotationType>) =>\n    onChange({\n      ...annotationQuery,\n      type: newValue.value!,\n    });\n\n  const onMaxLimitChange = (newValue: SelectableValue<number>) =>\n    onChange({\n      ...annotationQuery,\n      limit: newValue.value!,\n    });\n\n  const onMatchAnyChange = (newValue: React.ChangeEvent<HTMLInputElement>) =>\n    onChange({\n      ...annotationQuery,\n      matchAny: newValue.target.checked,\n    });\n\n  const onTagsChange = (tags: string[]) =>\n    onChange({\n      ...annotationQuery,\n      tags,\n    });\n\n  const onFormatCreateLabel = (input: string) => `Use custom value: ${input}`;\n\n  return (\n    <FieldSet className={styles.container}>\n      <Field label=\"Filter by\">\n        <Select\n          menuShouldPortal\n          inputId=\"grafana-annotations__filter-by\"\n          options={annotationTypes}\n          value={type}\n          onChange={onFilterByChange}\n        />\n      </Field>\n      <Field label=\"Max limit\">\n        <Select\n          menuShouldPortal\n          inputId=\"grafana-annotations__limit\"\n          width={16}\n          options={limitOptions}\n          value={limit}\n          onChange={onMaxLimitChange}\n        />\n      </Field>\n      {type === GrafanaAnnotationType.Tags && (\n        <>\n          <Field label=\"Match any\" description={matchTooltipContent}>\n            <Switch id=\"grafana-annotations__match-any\" value={matchAny} onChange={onMatchAnyChange} />\n          </Field>\n          <Field label=\"Tags\" description={tagsTooltipContent}>\n            <TagFilter\n              allowCustomValue\n              formatCreateLabel={onFormatCreateLabel}\n              inputId=\"grafana-annotations__tags\"\n              onChange={onTagsChange}\n              tagOptions={getAnnotationTags}\n              tags={tags ?? []}\n            />\n          </Field>\n        </>\n      )}\n    </FieldSet>\n  );\n}\n\nconst getStyles = () => {\n  return {\n    container: css`\n      max-width: 600px;\n    `,\n  };\n};\n","import { isString } from 'lodash';\nimport { from, merge, Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport {\n  AnnotationQuery,\n  AnnotationQueryRequest,\n  DataFrameView,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  DataSourceRef,\n  isValidLiveChannelAddress,\n  MutableDataFrame,\n  parseLiveChannelAddress,\n  toDataFrame,\n} from '@grafana/data';\nimport {\n  DataSourceWithBackend,\n  getBackendSrv,\n  getGrafanaLiveSrv,\n  getTemplateSrv,\n  StreamingFrameOptions,\n} from '@grafana/runtime';\nimport { migrateDatasourceNameToRef } from 'app/features/dashboard/state/DashboardMigrator';\n\nimport { getDashboardSrv } from '../../../features/dashboard/services/DashboardSrv';\n\nimport AnnotationQueryEditor from './components/AnnotationQueryEditor';\nimport { GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQuery, GrafanaQueryType } from './types';\n\nlet counter = 100;\n\nexport class GrafanaDatasource extends DataSourceWithBackend<GrafanaQuery> {\n  constructor(instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n    this.annotations = {\n      QueryEditor: AnnotationQueryEditor,\n      prepareAnnotation(json: any): AnnotationQuery<GrafanaAnnotationQuery> {\n        // Previously, these properties lived outside of target\n        // This should handle migrating them\n        json.target = json.target ?? {\n          type: json.type ?? GrafanaAnnotationType.Dashboard,\n          limit: json.limit ?? 100,\n          tags: json.tags ?? [],\n          matchAny: json.matchAny ?? false,\n        }; // using spread syntax caused an infinite loop in StandardAnnotationQueryEditor\n        return json;\n      },\n      prepareQuery(anno: AnnotationQuery<GrafanaAnnotationQuery>): GrafanaQuery {\n        let datasource: DataSourceRef | undefined | null = undefined;\n        if (isString(anno.datasource)) {\n          const ref = migrateDatasourceNameToRef(anno.datasource, { returnDefaultAsNull: false });\n          if (ref) {\n            datasource = ref;\n          }\n        } else {\n          datasource = anno.datasource as DataSourceRef;\n        }\n\n        return { ...anno, refId: anno.name, queryType: GrafanaQueryType.Annotations, datasource };\n      },\n    };\n  }\n\n  query(request: DataQueryRequest<GrafanaQuery>): Observable<DataQueryResponse> {\n    const results: Array<Observable<DataQueryResponse>> = [];\n    const targets: GrafanaQuery[] = [];\n    const templateSrv = getTemplateSrv();\n    for (const target of request.targets) {\n      if (target.queryType === GrafanaQueryType.Annotations) {\n        return from(\n          this.getAnnotations({\n            range: request.range,\n            rangeRaw: request.range.raw,\n            annotation: target as unknown as AnnotationQuery<GrafanaAnnotationQuery>,\n            dashboard: getDashboardSrv().getCurrent(),\n          })\n        );\n      }\n      if (target.hide) {\n        continue;\n      }\n      if (target.queryType === GrafanaQueryType.LiveMeasurements) {\n        let channel = templateSrv.replace(target.channel, request.scopedVars);\n        const { filter } = target;\n\n        // Help migrate pre-release channel paths saved in dashboards\n        // NOTE: this should be removed before V8 is released\n        if (channel && channel.startsWith('telegraf/')) {\n          channel = 'stream/' + channel;\n          target.channel = channel; // mutate the current query object so it is saved with `stream/` prefix\n        }\n\n        const addr = parseLiveChannelAddress(channel);\n        if (!isValidLiveChannelAddress(addr)) {\n          continue;\n        }\n        const buffer: Partial<StreamingFrameOptions> = {\n          maxLength: request.maxDataPoints ?? 500,\n        };\n        if (target.buffer) {\n          buffer.maxDelta = target.buffer;\n          buffer.maxLength = buffer.maxLength! * 2; //??\n        } else if (request.rangeRaw?.to === 'now') {\n          buffer.maxDelta = request.range.to.valueOf() - request.range.from.valueOf();\n        }\n\n        results.push(\n          getGrafanaLiveSrv().getDataStream({\n            key: `${request.requestId}.${counter++}`,\n            addr: addr!,\n            filter,\n            buffer,\n          })\n        );\n      } else {\n        if (!target.queryType) {\n          target.queryType = GrafanaQueryType.RandomWalk;\n        }\n        targets.push(target);\n      }\n    }\n\n    if (targets.length) {\n      results.push(\n        super.query({\n          ...request,\n          targets,\n        })\n      );\n    }\n\n    if (results.length) {\n      // With a single query just return the results\n      if (results.length === 1) {\n        return results[0];\n      }\n      return merge(...results);\n    }\n    return of(); // nothing\n  }\n\n  listFiles(path: string): Observable<DataFrameView<FileElement>> {\n    return this.query({\n      targets: [\n        {\n          refId: 'A',\n          queryType: GrafanaQueryType.List,\n          path,\n        },\n      ],\n    } as any).pipe(\n      map((v) => {\n        const frame = v.data[0] ?? new MutableDataFrame();\n        return new DataFrameView<FileElement>(frame);\n      })\n    );\n  }\n\n  metricFindQuery(options: any) {\n    return Promise.resolve([]);\n  }\n\n  async getAnnotations(options: AnnotationQueryRequest<GrafanaQuery>): Promise<DataQueryResponse> {\n    const templateSrv = getTemplateSrv();\n    const annotation = options.annotation as unknown as AnnotationQuery<GrafanaAnnotationQuery>;\n    const target = annotation.target!;\n    const params: any = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      limit: target.limit,\n      tags: target.tags,\n      matchAny: target.matchAny,\n    };\n\n    if (target.type === GrafanaAnnotationType.Dashboard) {\n      // if no dashboard id yet return\n      if (!options.dashboard.id) {\n        return Promise.resolve({ data: [] });\n      }\n      // filter by dashboard id\n      params.dashboardId = options.dashboard.id;\n      // remove tags filter if any\n      delete params.tags;\n    } else {\n      // require at least one tag\n      if (!Array.isArray(target.tags) || target.tags.length === 0) {\n        return Promise.resolve({ data: [] });\n      }\n      const delimiter = '__delimiter__';\n      const tags = [];\n      for (const t of params.tags) {\n        const renderedValues = templateSrv.replace(t, {}, (value: any) => {\n          if (typeof value === 'string') {\n            return value;\n          }\n\n          return value.join(delimiter);\n        });\n        for (const tt of renderedValues.split(delimiter)) {\n          tags.push(tt);\n        }\n      }\n      params.tags = tags;\n    }\n\n    const annotations = await getBackendSrv().get(\n      '/api/annotations',\n      params,\n      `grafana-data-source-annotations-${annotation.name}-${options.dashboard?.id}`\n    );\n    return { data: [toDataFrame(annotations)] };\n  }\n\n  testDatasource() {\n    return Promise.resolve();\n  }\n}\n\nexport interface FileElement {\n  name: string;\n  ['media-type']: string;\n}\n","import { DataSourcePlugin } from '@grafana/data';\n\nimport { QueryEditor } from './components/QueryEditor';\nimport { GrafanaDatasource } from './datasource';\nimport { GrafanaQuery } from './types';\n\nexport const plugin = new DataSourcePlugin<GrafanaDatasource, GrafanaQuery>(GrafanaDatasource).setQueryEditor(\n  QueryEditor\n);\n","import { DataQuery } from '@grafana/data';\nimport { LiveDataFilter } from '@grafana/runtime';\n\n//----------------------------------------------\n// Query\n//----------------------------------------------\n\nexport enum GrafanaQueryType {\n  LiveMeasurements = 'measurements',\n  Annotations = 'annotations',\n\n  // backend\n  RandomWalk = 'randomWalk',\n  List = 'list',\n  Read = 'read',\n  Search = 'search',\n}\n\nexport interface GrafanaQuery extends DataQuery {\n  queryType: GrafanaQueryType; // RandomWalk by default\n  channel?: string;\n  filter?: LiveDataFilter;\n  buffer?: number;\n  path?: string; // for list and read\n  query?: string; // for query endpoint\n}\n\nexport const defaultQuery: GrafanaQuery = {\n  refId: 'A',\n  queryType: GrafanaQueryType.RandomWalk,\n};\n\n//----------------------------------------------\n// Annotations\n//----------------------------------------------\n\nexport enum GrafanaAnnotationType {\n  Dashboard = 'dashboard',\n  Tags = 'tags',\n}\n\nexport interface GrafanaAnnotationQuery extends GrafanaQuery {\n  type: GrafanaAnnotationType; // tags\n  limit: number; // 100\n  tags?: string[];\n  matchAny?: boolean; // By default Grafana only shows annotations that match all tags in the query. Enabling this returns annotations that match any of the tags in the query.\n}\n"],"names":["QueryEditor","PureComponent","constructor","props","super","channels","channelFields","label","value","GrafanaQueryType","description","sel","onChange","query","onRunQuery","this","queryType","loadChannelInfo","channel","item","fields","Array","isArray","map","v","length","filter","tf","state","find","f","key","txt","buffer","rangeUtil","err","console","warn","e","checkAndUpdateValue","target","path","config","queryTypes","push","getBackendSrv","fetch","url","subscribe","next","channelInfo","data","c","distinctFields","Set","frame","dataFrameFromJSON","add","name","from","n","minute_rate","setState","loadFolderInfo","targets","refId","getDataSourceSrv","get","then","ds","rsp","folders","values","toArray","componentDidMount","renderMeasurementsQuery","currentChannel","has","formattedTime","className","InlineField","grow","labelWidth","Select","menuShouldPortal","options","onChannelChange","allowCustomValue","backspaceRemovesValue","placeholder","isClearable","noOptionsMessage","formatCreateLabel","input","onFieldNamesChange","isSearchable","isMulti","Input","width","defaultValue","onKeyDown","handleEnterKey","onBlur","handleBlur","spellCheck","Alert","title","severity","renderListPublicFiles","currentFolder","InlineFieldRow","onFolderChanged","renderSearch","handleSearchEnterKey","handleSearchBlur","render","defaultQuery","onQueryTypeChange","tagsTooltipContent","annotationTypes","GrafanaAnnotationType","limitOptions","limit","String","AnnotationQueryEditor","annotationQuery","matchAny","tags","type","styles","getStyles","FieldSet","container","Field","inputId","newValue","Switch","id","checked","TagFilter","tagOptions","getAnnotationTags","css","counter","GrafanaDatasource","DataSourceWithBackend","instanceSettings","annotations","prepareAnnotation","json","prepareQuery","anno","datasource","isString","ref","migrateDatasourceNameToRef","returnDefaultAsNull","request","results","templateSrv","getTemplateSrv","getAnnotations","range","rangeRaw","raw","annotation","dashboard","getDashboardSrv","getCurrent","hide","replace","scopedVars","startsWith","addr","parseLiveChannelAddress","isValidLiveChannelAddress","maxLength","maxDataPoints","maxDelta","to","valueOf","getGrafanaLiveSrv","getDataStream","requestId","merge","of","listFiles","pipe","MutableDataFrame","DataFrameView","metricFindQuery","Promise","resolve","params","dashboardId","delimiter","t","renderedValues","join","tt","split","toDataFrame","testDatasource","plugin","DataSourcePlugin","setQueryEditor","RandomWalk"],"sourceRoot":""}